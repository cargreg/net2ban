{"name":"Net2ban","tagline":"A tool to remotely execute fail2ban actions","body":"The problem\r\n-----------\r\nImagine a common scenario in which you have to manage multiple servers and all those servers send its logs to a remote centralized syslog server. In this scenario may that be even the final servers do not store its logs locally unless a network connection problem occurs.\r\n\r\nSo you have a centralized syslog server in which you store (among others) all detected break-in attempts, brute force attacks, etc. The next question is, once you have detected a break-in attempt or a brute force attack in one of your servers, how can you remotely ban the attacker IP in that server and in the other ones?\r\n\r\nThe first response: Fail2Ban\r\n----------------------------\r\nFail2Ban is a great and very powerful tool, but it is designed to work locally, what turns it  in a nightmare when trying to use it in our scenario. Even if the logs were stored locally, you still have to manage the fail2ban filters and actions in all servers, although this approach could be solved by using some kind of shared storage, etc.\r\n\r\nThe good response: Net2Ban\r\n--------------------------\r\nSince I did not found any open source project to manage the given approach, I decided to write my own solution, here is where net2ban comes in rescue.\r\n\r\nWhat is Net2Ban?\r\n----------------\r\nAs you can guess, Net2Ban is inspired in fail2ban, but it is much more simple and flexible. It has two *main* parts: Server, and client. Aditionaly it uses RabbitMQ as message brooker to communicate from server to clients, and has a tool to send commands to the server in order to propagate the actions.\r\n\r\nSecurity\r\n--------\r\nFor each communication between nodes, net2ban uses AES256 encryption in CBC mode, PBKDF2 to generate the session key and HMAC-SHA256, in order to protect and guarantee the integrity,confidentiality and authenticity of each message. The parameters to set up the encryption schema will be explained in the next points.\r\n\r\n\r\nWorkflow\r\n------------\r\nTo identify the difference between fail2ban and net2ban, and understand how they can be mixed, here is a simple schema representing the workflow of both tools:\r\n\r\nFail2Ban:\r\n<dl><pre>\r\n                            --> filters ->-\r\n                          2 |             |\r\n  ##############   1    ########################   3    ###########\r\n  # LOG SOURCE # -----> # Fail2Ban (Detection) # -----> # Actions #\r\n  ##############        ########################        ###########\r\n</pre></dl>\r\n\r\n\r\nNet2Ban:\r\n<dl><pre>\r\n                           --> intelligence ->-\r\n                         2 |                  |\r\n                        ########################\r\n  ##############   1    #   DETECTION AND/OR   #   3    ###########   \r\n  # LOG SOURCE # -----> #  CORRELATION ENGINE  # -----> # ACTIONS # ---\r\n  ##############        ########################        ###########   | 4\r\n                                                                      |\r\n   -------------------------------------------------------------------|\r\n   |\r\n 4 |    ###############################   5    ###################\r\n   |--> # Net2Ban: DO 'X' ACTION WITH # -----> # RABBITMQ SERVER # --\r\n        # 'Y' IP AND 'Z' PORT(S)      #        ###################  |\r\n        ###############################                             | 6\r\n                                                                    |\r\n  ------------------------------------------------------------------|\r\n  |\r\n6 |    ############################\r\n  |    # NET2BAN SERVER: FORWARDS #   7    ###################################\r\n  |--> # THE MESSAGE TO THE NODES # -----> # NET2BAN CLIENT: DOES 'X' ACTION #\r\n       # THROUGH RABBITMQ         #        # WITH 'Y' IP AND 'Z' PORT(S)     #\r\n       ############################        ###################################\r\n</pre></dl>\r\n\r\n\r\nWhy RabbitMQ?\r\n-------------\r\nIt is true that there are many message brokers such as reddit or activemq, some of them give you a higher performance level when dealing in big environments such as WANs, but in my case, there was a RabbitMQ server already installed in the network. On the other hand, net2ban can be modified to work with a message broker specified in the configuration file. This approach could be made in future versions...\r\n\r\nInstallation\r\n============\r\n\r\n##### Common Tasks\r\nThe following tasks are commons and required to install net2ban in the servers as well as in the clients:\r\n\r\n<dl><pre>\r\napt-get install python-pika python-passlib python-crypto\r\ngit clone https://github.com/sch3m4/net2ban.git net2ban\r\ncd net2ban\r\nmkdir -p /user/share/net2ban/actions\r\nuseradd -r -M net2ban -s /bin/false -b /usr/share\r\ncp -r net2ban /usr/share/net2ban/\r\ncp net2ban.py /usr/share/net2ban/\r\ncp net2ban.cfg /usr/share/net2ban/\r\ncp net2ban_init.d /etc/init.d/net2ban\r\nchown root:root /etc/init.d/net2ban\r\nchmod 0750 /etc/init.d/net2ban\r\nupdate-rc.d net2ban defaults\r\n</pre></dl>\r\n\r\n##### Server\r\nSome extra actions to be made on server side:\r\n<dl><pre>\r\napt-get install rabbitmq-server fail2ban\r\nservice fail2ban stop\r\ncp net2ban.cfg /usr/share/net2ban/\r\ncp net2banctl.py /sbin/net2banctl\r\nchown root:root /sbin/net2banctl\r\nchmod 0750 /sbin/net2banctl\r\n</pre></dl>\r\n\r\n##### Client\r\nSome extra actions to be made on client side:\r\n<dl><pre>\r\napt-get install sudoers\r\n</pre></dl>\r\n\r\nIn order to allow net2ban user execute the iptables binary, add the following entry to your \"/etc/sudoers\" file:\r\n<dl><pre>\r\necho 'net2ban ALL=NOPASSWD: /sbin/iptables' >> /etc/sudoers\r\n</pre></dl>\r\n\r\nNOTE: Add an entry like the aforementioned for each privileged command susceptible of being executed by net2ban clients\r\n\r\n##### Final common steps\r\nAs final steps, don't forget to change the owner and permissions of net2ban files:\r\n\r\n<dl><pre>\r\nchown -R net2ban:net2ban /usr/share/net2ban\r\nchmod -R 0750 /usr/share/net2ban\r\n</pre></dl>\r\n\r\nConfiguration schema\r\n====================\r\n\r\nThe net2ban.cfg looks as follows:\r\n<dl><pre>\r\n[global]\r\nserver = 172.16.0.1\r\nrounds = 12000\r\nsecret = 57bae6f17927fee0309cd0fcf900903d0bf49277\r\nmode = server\r\nvalid_wtime = 3600\r\nauthkey = fe64809ba0286c72123d15ffb3554f261ef835d0\r\nqueue_prefix = net2ban_\r\n\r\n[server]\r\ninput = input_net2ban\r\nkey = 1e3648858a30a105374c1a8a7f05e4fc0dff2abc\r\n\r\n[keygen]\r\nkeylen = 40\r\n\r\n[client1]\r\nkey = key1\r\n</pre></dl>\r\n\r\n##### global\r\nThe options in this sections are used by the server and clients. It can be used to set some parameters to a default value.\r\n###### server\r\nThis is the host/ip of the RabbitMQ server, used to establish the communication between the server and clients.\r\n###### mode\r\nThis is the working mode of this instance of net2ban, and have to be set to \"client\" or \"server\".\r\n###### valid_wtime\r\nValid window time for the messages, in seconds. All those messages that have been sent before the relative \"valid_wtime\" will be discarted.\r\n###### rounds\r\nRounds to be used when generating the session key by using PBKDF2\r\n###### secret\r\nShared secret to be used with the key of each client, to generate the session key by using PBKDF\"\r\n###### authkey\r\nAuthentication key to generate the HMAC-SHA256 of each message\r\n###### queue_prefix\r\nPrefix to create a queue for each client\r\n\r\n##### server\r\nThis section is specific to the server side.\r\n###### input\r\nQueue name to read the messages and forward them\r\n###### key\r\nKey used to decrypt the messages received\r\n\r\n##### keygen\r\n###### keylen\r\nWhen generating random keys to be used as auth key/secret/key through net2banctl, this parameter set the length of the generated random string\r\n\r\n##### client1\r\nThe name of this section is arbitrary and should not match with other entries. The name of this section will be used as client's name.\r\n###### key\r\nKey used to decrypt the messages received\r\n\r\n#### Specifying individual parameters\r\nThe above configuration schema is the minimum required, as it can be modified by adding some parameters to server and clients sections in order to override the default ones.\r\nOn this point, you can add the following options to any section related to clients/server:\r\n..* rounds\r\n..* secret\r\n..* key\r\n..* valid_wtime\r\n..* authkey\r\n\r\nReferring to the cryptographic values, the only key that must be similar in server and client side, is the \"secret\" option. If you locally modify a key on client side, remember to set the same key in the section belonging to that client in net2ban.cfg on server side.\r\n\r\nSample configuration\r\n====================\r\nOn this point we're going to generate a configuration file to use the RabbitMQ server on 172.16.15.2 using two clients: client1 and client2. Moreover we will use individual configurations for the clients.\r\n\r\n## Server side\r\nAt this step we are going to modify the net2ban.cfg file to set the proper values in order to work on server side, and afterwards copy the configuration to the clients.\r\n\r\nThe minimum required configuraton looks as follows:\r\n<dl><pre>\r\n[global]\r\nserver = 172.16.15.2\r\nrounds = 12000\r\nsecret = 57bae6f17927fee0309cd0fcf900903d0bf49277\r\nmode = server\r\nvalid_wtime = 3600\r\nauthkey = fe64809ba0286c72123d15ffb3554f261ef835d0\r\nqueue_prefix = net2ban_\r\n\r\n[server]\r\ninput = input_net2ban\r\nkey = 1e3648858a30a105374c1a8a7f05e4fc0dff2abc\r\n\r\n[keygen]\r\nkeylen = 40\r\n\r\n[client1]\r\nkey = key1\r\n\r\n[client2]\r\nkey = key2\r\n</pre></dl>\r\n\r\nTo generate the client keys, we will use net2banctl:\r\n<dl><pre>\r\n$ for i in $(seq 1 2); do net2banctl gen_random ; done\r\nca82cd669623f6434e02eecade0236b50fc18cb3\r\n767c138a4483e692f41af3d1491f06c0ead41b5b\r\n$\r\n</pre></dl>\r\n\r\nNow, set the 'key' clients option to these values:\r\n\r\n<dl><pre>\r\n[client1]\r\nkey = ca82cd669623f6434e02eecade0236b50fc18cb3\r\n\r\n[client2]\r\nkey = 767c138a4483e692f41af3d1491f06c0ead41b5b\r\n</pre></dl>\r\n\r\nIf you want some client to use a different value of \"rounds\", just specify it in his section:\r\n\r\n<dl><pre>\r\n[client2]\r\nrounds = 100\r\nkey = 767c138a4483e692f41af3d1491f06c0ead41b5b\r\n</pre></dl>\r\n\r\n## Client side\r\nIndeed the client configuration is almost done. On this step you still need access to the server.\r\n\r\nTo verify that net2banctl can see the configuration file and the clients specified on it, execute:\r\n<dl><pre>\r\n$ net2banctl list_clients\r\nclient1\r\nclient2\r\n</pre></dl>\r\n\r\nNow, we need to export the configuration of each client and save it in /usr/share/net2ban/net2ban.cfg on each client. To do that, execute the following on the server:\r\n<dl><pre>\r\n$ net2banctl get_client client1 > client1.cfg\r\n$ cat client1.cfg\r\n[global]\r\nserver = 172.16.15.2\r\nrounds = 12000\r\nsecret = 57bae6f17927fee0309cd0fcf900903d0bf49277\r\nmode = client\r\nvalid_wtime = 3600\r\nauthkey = fe64809ba0286c72123d15ffb3554f261ef835d0\r\nqueue_prefix = net2ban_\r\n\r\n[keygen]\r\nkeylen = 40\r\n\r\n[client1]\r\nkey = ca82cd669623f6434e02eecade0236b50fc18cb3\r\n$\r\n</pre></dl>\r\n\r\n## Integrating net2ban & fail2ban\r\nIn order to use net2ban in conjunction with fail2ban, you need to do some changes to your fail2ban configuration. First of all, copy your fail2ban action file (defined in /etc/fail2ban/jail.conf, [DEFAULT]/banaction) to /usr/share/net2ban/actions. In my case, I'm using \"iptables-multiport\":\r\n\r\n<dl><pre>\r\n$ cp /etc/fail2ban/actions.d/iptables-multiport.conf /usr/share/net2ban/actions/\r\n</pre></dl>\r\n\r\nEdit the original fail2ban action file (in my case: /etc/fail2ban/actions.d/iptables-multiport.conf) and modify the value of the defined actions to the following ones:\r\n\r\n<dl><pre>\r\n[Definition]\r\nactionstart = net2banctl exec iptables-multiport actionstart name=&lt;name&gt; chain=&lt;chain&gt; protocol=&lt;protocol&gt; port=&lt;port&gt;\r\nactionstop = net2banctl exec iptables-multiport actionstop name=&lt;name&gt; chain=&lt;chain&gt; protocol=&lt;protocol&gt; port=&lt;port&gt;\r\nactionban = net2banctl exec iptables-multiport actionban name=&lt;name&gt; ip=&lt;ip&gt;\r\nactionunban = net2banctl exec iptables-multiport actionunban name=&lt;name&gt; ip=&lt;ip&gt;\r\n# cheats fail2ban\r\nactioncheck = echo -n \"&lt;chain&gt;&lt;name&gt;\" && exit 0\r\n\r\n[Init]\r\nname = default\r\nport = ssh\r\nprotocol = tcp\r\nchain = INPUT\r\n</pre></dl>\r\n\r\nWe're almost done. The final step is to start the net2ban daemon in server and clients side and send the \"actions\" file to the clients:\r\n\r\n<dl><pre>\r\n$ for i in $(net2banctl list_clients); do net2banctl update $i /usr/share/net2ban/actions/iptables-multiport.conf ; done\r\n$\r\n</pre></dl>\r\n\r\nIMPORTANT: Remember to modify the actions file and add \"sudo\" before \"iptables\" to execute each command as root.\r\n\r\nPersonally I prefer to ban the IP without taking care about the port, so the given IP is globally banned, here is my \"iptables-multiport.conf\" actions file:\r\n\r\n<dl><pre>\r\n[Definition]\r\nactionstart = sudo iptables -N fail2ban-&lt;name&gt;\r\n              sudo iptables -A fail2ban-&lt;name&gt; -j RETURN\r\n              sudo iptables -I &lt;chain&gt; -p &lt;protocol&gt; -j fail2ban-&lt;name&gt;\r\nactionstop = sudo iptables -D &lt;chain&gt; -p &lt;protocol&gt; -j fail2ban-&lt;name&gt;\r\n             sudo iptables -F fail2ban-&lt;name&gt;\r\n             sudo iptables -X fail2ban-&lt;name&gt;\r\nactionban = sudo iptables -I fail2ban-&lt;name&gt; 1 -s &lt;ip&gt; -j DROP\r\nactionunban = sudo iptables -D fail2ban-&lt;name&gt; -s &lt;ip&gt; -j DROP\r\n[Init]\r\nname = default\r\nport = ssh\r\nprotocol = tcp\r\nchain = INPUT\r\n</pre></dl>\r\n\r\nAfter that you should see something like this in your syslog:\r\n\r\n<dl><pre>\r\n........ net2ban: File \"iptables-multiport\" updated\r\n</pre></dl>\r\n\r\n\r\nNot restricted to Fail2Ban\r\n--------------------------\r\nnet2ban is not only restricted to be used with fail2ban, due to its architecture it can be used with any software. Imagine the following scenario:\r\n\r\n..* User 'user1' log in into a corporate application\r\n..* User 'user1' has not loged in his workstation\r\n\r\nThe correlation engine detects an abnormal behaviour and executes net2banctl to automatically ban the IP on the other servers and/or applications (keep in mind that you are not limited to execute the iptables binary on client side) and report it.\r\n\r\nSaving net2ban server logs\r\n--------------------------\r\nBy default, net2ban uses syslog to send logs, so if you want to save the logs generated by the tool in a different file (by default is logs to \"daemon\" file) you can modify your syslog-ng rules and add the following lines:\r\n\r\n<dl><pre>destination d_net2ban { file ( \"/var/log/net2ban.log\" ); };\r\ndestination d_rnet2ban { file ( \"/var/log/remote/$FULLHOSTNAME/net2ban.log\" );\r\nfilter f_net2ban { facility ( daemon ); program ( \"net2ban\" ); };\r\nlog { source(s_src); filter(f_net2ban); destination(d_net2ban); flags ( final ); };\r\nlog { source(s_udp); filter(f_net2ban); destination(d_rnet2ban); flags ( final ); };</pre></dl></pre></dl>\r\n\r\nKeep in mind that the \"log\" rules must be the first matching rules in order to avoid duplicate logs.\r\n\r\nSample output\r\n-------------\r\nWhenever fail2ban detects a break-in attept, it will generate an entry in the log like this:\r\n\r\n<dl><pre>.... fail2ban.actions: WARNING [dovecot] Ban 95.48.84.XXX</pre></db>\r\n\r\nThat action will execute net2banctl and send the message to the server, and the following log entry will be generated in your server:\r\n\r\n<dl><pre>..... net2ban: Forwarding: exec/iptables-multiport</pre></db>\r\n\r\nFinally, the net2ban nodes will receive the message, send a log entry and execute the action:\r\n\r\n<dl><pre>..... net2ban: IP 95.48.84.XXX banned</pre></db>\r\n\r\n<dl><pre>$ iptables -nvL | grep -i 95.48.84.XXX\r\n    9   564 DROP       all  --  *      *       95.48.84.XXX         0.0.0.0/0\r\n$</pre></db>\r\n\r\nConsiderations\r\n==============\r\nnet2ban uses persistent queues on RabbitMQ, if a client is not connected and the server sends five messages to that client, the messages are stored in the queue, waiting for the client to connect and read them.\r\nOn that point is very important the parameter \"valid_wtime\" in order to discard old messages.\r\nEven in a normal behaviour, and due to the parameter \"valid_wtime\" is very important that all nodes to be synchronized (ex: by using NTP)\r\n\r\nCode issues\r\n===========\r\nThe code is *very dirty*, it's a program written very fast \"to work right now\"...","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}